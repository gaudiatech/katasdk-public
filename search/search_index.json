{"config":{"lang":["en","fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PYVED ENGINE","text":""},{"location":"#introduction","title":"Introduction","text":"<p>PYV is the name of a game engine fully written in python.</p> <p>It's a wrapper around the popular <code>pygame</code> librabry, therefore if you have some prior experience with developing games with <code>pygame</code>, transitioning to PYV should be extremely easy!</p>"},{"location":"#why-pyved","title":"Why Pyved","text":"<p>Confusion appears to exist within the community regarding the differentiation between a Python package, and a game engine.</p> <p>It's crucial to understand that although Pygame functions as a regular Python package/library. It doesn't provide the extensive array of features present in a specialized 2D game engine! Consequently, it might not satisfy all the prerequisites essential for the development of a fully-realized game.</p> <p>Pyved wants to create a new standard for python game development adding new features and possibilities, everything will be detailed into the features section.</p>"},{"location":"#goals","title":"Goals","text":"<ul> <li> <p>Objective: The primary objective of PYV is to elevate the accessibility, learnability, and overall experience of Python game development to new heights.</p> </li> <li> <p>Aspiration: PYV aspires to elevate Python game development by ensuring it becomes easier to use, easier to learn, and more reliable.</p> </li> </ul> <p>But how a simple pygame wrapper will do this ?</p>"},{"location":"#features","title":"Features","text":"<p>The game engine comes packed with a ton of features:</p> <ul> <li>Design pattern (Such as : ECS, Mediator and MVC)</li> <li>Event queue (simplifies the use of patterns such as: Mediator, the MVC pattern)</li> <li>Gamestate stack, state management via events</li> <li>Simple GUI creation: buttons, checkboxes, etc.</li> <li>Tileset loading, sprite animation</li> <li>Tilemap parser (based on .tmx or .tsj file formats)</li> <li>Mathematical tools: matrices ; vectors ; gradient noise functions (-&gt;procedural generation)</li> <li>Helper classes for multiple types of games : Roguelike, RPG games, Card games (Poker, Blackjack ...).</li> <li>Helper classes for adding artificial opponents/intelligent entities (NPCs) to your game</li> <li>Isometric 3D game engine </li> <li>Ease of distribution (Our platform KataGames will help deploy the game and make it playable through a browser in seconds)</li> </ul> <p>... It's only the beginning. More features will be added soon.</p>"},{"location":"#galery","title":"Galery","text":""},{"location":"#game-architecture","title":"Game architecture","text":"<p>We mentionned designs pattern before, let's make a brief summary here, but you can find more details in the relevant pages.</p>"},{"location":"#ecs-entity-component-system","title":"ECS : Entity Component System","text":"<p>The ECS pattern is a recent industry standard for game development, it's concept is to decompose game entities into \"bricks\" kind of like legos, so you can assemble things in a easier way and avoid confusion.</p> <p>Read more in the <code>ECS</code> section.</p>"},{"location":"#mediator","title":"Mediator","text":""},{"location":"Entity%20Component%20System/A%20bit%20of%20theory/","title":"A bit of theory","text":""},{"location":"Entity%20Component%20System/A%20bit%20of%20theory/#ecs-entity-component-system","title":"ECS : Entity Component System","text":"<p>Have you heard about : Entity Component System (ECS) for Game Development?</p> <p>The Entity Component System (ECS) is a software architectural pattern commonly used in game development to manage and organize game objects, their behavior, and their data.  It is designed to improve code performance, scalability, and flexibility by separating the game's logic into distinct components and entities.</p> <p>Key Components of ECS are:</p> <ol> <li> <p>Entities: In ECS, an entity represents a game object or an abstract entity in your game world. An entity is essentially a unique identifier, often just an integer or a handle, that is used to group and manage related components. Entities themselves don't contain any behavior or data; they serve as a way to assemble components.</p> </li> <li> <p>Components: Components are the building blocks of an ECS system. Each component represents a single, self-contained piece of data and behavior. For example, in a 2D game, you might have components for position, sprite rendering, physics, and more. Components do not have any logic themselves; they are just containers for data.</p> </li> <li> <p>Systems: Systems are responsible for defining the behavior and operations performed on entities that have specific combinations of components. Systems process entities based on the components they contain, and they can perform various tasks such as updating the physics simulation, rendering objects, handling input, and more. Systems are typically where the game's logic resides.</p> </li> </ol> <p>In summary a component is a collection of field values.</p> <p>An entity is a container of components</p> <p>A system is a part of the game logic, and have access to both entities and components </p> <p>Let's explore ECS through an example: a role-playing game (RPG) where characters roam a virtual world.  We'll consider two types of entities: \"Player\" and \"NPC.\"</p>"},{"location":"Entity%20Component%20System/A%20bit%20of%20theory/#components","title":"Components :","text":"<p>Stats Component: Health points (HP), attack power, defense, and other attributes that define a character's abilities.</p> <p>Position Component: The character's coordinates in the game world.</p> <p>Control Component: The possible controls in the game world</p>"},{"location":"Entity%20Component%20System/A%20bit%20of%20theory/#entities","title":"Entities:","text":"<p>Player Entity: An entity representing the player character.  It contains Stats, Position and Control components.</p> <p>NPC Entity: Represents non-playable characters in the game.  It also contains Stats and Position components.</p>"},{"location":"Entity%20Component%20System/A%20bit%20of%20theory/#systems","title":"Systems:","text":"<p>Rendering System: Responsible for drawing characters on the screen based on their Graphics components.</p> <p>Collision Detection System: Detects collisions between entities in the game world.  For example, it can determine if the player character collides with an NPC or an obstacle.</p> <p>Combat System: Handles combat-related logic, including attacks, damage calculation, and health point updates based on the Stats components.</p> <p>Movement System: Manages character movement based on their Position components and velocity. For example, it moves characters in response to player input or AI.</p>"},{"location":"Game%20Tutorials/Breakout/","title":"Tutorial Breaker","text":"<p>This tutorial is here to help you create a block breaker type game from scratch.</p> <p>This tutorial can also be used as a nice base to understand and experiment with the ECS pattern.</p> <p>Note that the game in its final state is already available in the <code>pyved-engine</code> in the <code>pyv-cli</code>.</p> <p>If you need further help for using PYV, you can always refer to the pyved-engine full docs homepage.</p>"},{"location":"Game%20Tutorials/Breakout/#step-0-getting-started","title":"Step 0. Getting Started","text":""},{"location":"Game%20Tutorials/Breakout/#either-download-the-init-or-just-the-template","title":"Either Download the init, or just the template","text":"<p>If you want to build upon the foundation of the breaker template, you can download it by doing the following</p> <pre><code>pyv-cli init myGame\npyv-cli play myGame\n</code></pre> <p>And choose the Breakout template.</p> <p>Note that this tutorial won't focus on building upon the foundation, instead the focus is on how to build on nothing and manage to create such a game.</p> <p>So for this, we will choose the empty template instead.</p> <p>Your folder should look something like this.</p> <pre><code>.\n\u2514\u2500\u2500 YourBundleName/\n    \u251c\u2500\u2500 cartridge/\n    \u2502   \u251c\u2500\u2500 __pycache__/\n    \u2502   \u251c\u2500\u2500 gamedef.py\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 metadat.json\n    \u2502   \u2514\u2500\u2500 pimodules.py\n    \u251c\u2500\u2500 __pycache__/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 vm.py\n    \u2514\u2500\u2500 vmslateL.py\n</code></pre>"},{"location":"Game%20Tutorials/Breakout/#step-1-create-the-necessary-files-for-the-ecs","title":"Step 1 : Create the necessary files for the ECS","text":"<p>As of now, all of the files used in an ECS configuration aren't auto generated, this might change in the future, but since you're here to learn everything on how to create a game using Pyved and ECS, let's get into it.</p> <p>Go inside <code>cartridge</code> and create the following file, they'll be useful later :</p> <ul> <li>shared.py</li> <li>systems.py</li> <li>world.py</li> </ul> <p>These files will store nearly all of your ECS code.</p>"},{"location":"Game%20Tutorials/Breakout/#step-2-creating-the-foundations","title":"Step 2 : Creating the foundations","text":"<p>In this part, you will learn how to create your first entities and draw them on your screen.</p>"},{"location":"Game%20Tutorials/Breakout/#creation-of-archetypes-and-entities","title":"Creation of Archetypes and Entities","text":"<p>First, let's create all of our constants in our <code>shared.py</code> :</p> <pre><code>import random\n\n\nscreen = None\nblocks_pop = None\n\n# (Size of break-out blocks)\nBLOCK_W = 54\nBLOCK_H = 30\nBLOCK_SPACING = 2\nWALL_X, WALL_Y = 4, 80\nPLAYER_SPEED = 10\n\n# ball-related\nBALL_INIT_POS = 480, 277\nBALL_SIZE = 22\n</code></pre> <p>We will use all of those constants laters, but they are important.</p> <p>Secondly we will create all of our entities, let's head inside <code>gamedef.py</code></p> <pre><code>from . import pimodules\nfrom . import shared\nfrom . import systems\nfrom .world import world\n\npyv = pimodules.pyved_engine\n@pyv.declare_begin\ndef init_game(vmst=None):\n    pyv.init(wcaption='N\u00e9ant')\n</code></pre> <p>Let's create our archetypes, this is how we will create the different entities : </p> <pre><code>    pyv.define_archetype('player', (\n        'speed', 'controls', 'body'\n    ))\n    pyv.define_archetype('block', ('body', ))\n    pyv.define_archetype('ball', ('body', 'speed_Y', 'speed_X'))\n</code></pre> <p>We can now go into <code>world.py</code>, to create our entities :</p> <pre><code>from . import shared\nfrom . import pimodules\npyv = pimodules.pyved_engine\n\npygame = pyv.pygame\n\n\nclass world:\n\n    def create_player():\n        player = pyv.new_from_archetype('player')\n        pyv.init_entity(player, {\n            'speed': 0.0, \n            'controls':{'left': False, 'right': False},\n            'body': pygame.rect.Rect(900,600, shared.BLOCK_W, shared.BLOCK_H)\n        })\n\n</code></pre> <p>We are creating a create_player function, this will create the entities with our default settings, we will do the same for every entity present in our game.</p> <p>We give it, a speed, some controls, here we only give it left and right, as we don't need other directions.</p> <p>And finally a body, so that our player have a hitbox.</p> <pre><code>    def create_ball():\n        ball = pyv.new_from_archetype('ball')\n        pyv.init_entity(ball, {\n            'speed_X' :random.uniform(-3.0, 3.0), \n            'speed_Y': 5.0, \n            'body': pygame.rect.Rect(shared.BALL_INIT_POS[0],shared.BALL_INIT_POS[1], shared.BALL_SIZE, shared.BALL_SIZE)\n        })\n</code></pre> <p>We will create our ball too, we will keep the same logic, and create, it needs a speed to move, and a hitbox to detect collisions.</p> <pre><code>def create_blocks():\n        bcy = 0 \n        LIMIT = 960/(shared.BLOCK_W + shared.BLOCK_SPACING)\n        for row in range(5):\n            bcy = bcy+shared.BLOCK_H + shared.BLOCK_SPACING\n            bcx = -shared.BLOCK_W\n            for column in range(round(LIMIT)):\n                bcx = bcx +shared.BLOCK_W + shared.BLOCK_SPACING\n                rrect = pygame.rect.Rect(0 + bcx, 0 + bcy, shared.BLOCK_W, shared.BLOCK_H)\n\n                pyv.init_entity(pyv.new_from_archetype('block'),{\n                    'body': rrect\n                })\n</code></pre> <p>Here the code is a bit different, since there's more than one block, we will loop over it to generate as many entity as needed.</p> <p>Here we fill the screen from left to right, and on 5 row with blocks.</p> <p>We can now head back into <code>gamedef.py</code> and finalise the creation of our entities.</p> <pre><code>@pyv.declare_begin\ndef init_game(vmst=None):\n    pyv.init()\n    pyv.define_archetype('player', (\n        'speed', 'controls', 'body'\n    ))\n    pyv.define_archetype('block', ('body', ))\n    pyv.define_archetype('ball', ('body', 'speed_Y', 'speed_X'))\n    world.create_player()\n    world.create_ball()\n    world.create_blocks()\n    pyv.bulk_add_systems(systems)\n</code></pre> <p>Here we added the call to the different functions we made in the <code>world.py</code>, so that now, when we launch our game, we create actual entities instead of just their archetypes.</p> <p>As for the line <code>pyv.bulk_add_systems(systems)</code> we will get back to it soon.</p>"},{"location":"Game%20Tutorials/Breakout/#creating-systems","title":"Creating systems","text":"<p>The systems are an essentiel part of the ECS, it's basically all of the logic happening in the game.</p> <p>Let's head inside <code>systems.py</code> :</p> <pre><code>from . import shared\nfrom . import pimodules\npyv = pimodules.pyved_engine\npyv.bootstrap_e()\n\n__all__ = [\n\n    'gamectrl_sys'\n]\n\ndef gamectrl_sys(entities, components):\n    pg = pyv.pygame\n    for ev in pg.event.get():\n        if ev.type == pg.KEYDOWN and ev.key == pg.K_ESCAPE:\n            pyv.vars.gameover = True \n\n</code></pre> <p>This is a base setup for a <code>systems.py</code> file, let's make it a bit more full with all of our base systems.</p> <pre><code>from . import shared\nfrom . import pimodules\n\npyv = pimodules.pyved_engine\npyv.bootstrap_e()\n\n__all__ = [\n    'controls_sys',\n    'physics_sys',\n    'rendering_sys',\n    'gamectrl_sys'\n]\n\ndef controls_sys(entities, components):\n    #Empty for now\n\ndef physics_sys(entities, components):\n    #Empty for now\n\ndef rendering_sys(entities, components):\n    #Empty for now\n\ndef gamectrl_sys(entities, components):\n    pg = pyv.pygame\n    for ev in pg.event.get():\n        if ev.type == pg.KEYDOWN and ev.key == pg.K_ESCAPE:\n            pyv.vars.gameover = True \n\n</code></pre> <p>Now, we will create our rendering system, to at least have some graphics and wrap this step up.</p> <pre><code>def rendering_sys(entities, components):\n    \"\"\"\n    displays everything that can be rendered\n    \"\"\"\n    scr = shared.screen\n\n    scr.fill((0, 0, 0))\n    pl_ent = pyv.find_by_archetype('player')[0]\n    li_blocks = pyv.find_by_archetype('block')\n    ball = pyv.find_by_archetype('ball')[0]\n\n    pyv.draw_rect(scr, 'white', pl_ent['body'])\n    pyv.draw_rect(scr, 'blue', ball['body'])\n    for b in li_blocks:\n        pyv.draw_rect(scr, 'purple', b['body'])\n</code></pre> <p>What we do here, is first fill the screen in black, then find the different lists of entities for each archetypes.</p> <p>We then simply give their hitbox a graphical representation with different colors.</p> <p>Since the player and ball are alone, we just go for the first one of the list, and we iterate over the different blocks we created before.</p> <p>Let's head one last time into <code>gamedef.py</code>, and add the few details missing in order to display everything fine.</p> <pre><code>\n@pyv.declare_begin\ndef init_game(vmst=None):\n    pyv.init()\n    screen = pyv.get_surface() \n    shared.screen = screen\n    pyv.define_archetype('player', (\n        'speed', 'controls', 'body'\n    ))\n    pyv.define_archetype('block', ('body', ))\n    pyv.define_archetype('ball', ('body', 'speed_Y', 'speed_X'))\n    world.create_player()\n    world.create_ball()\n    world.create_blocks()\n    pyv.bulk_add_systems(systems)\n</code></pre> <p>Here we added the screen creation to our initialisation sequence, this is also where the bulk system is used, since we created a rendering system, we need to load it in our game.</p> <p>Now, in order to have something displays and refresh, we will also modify our update like so:</p> <pre><code>@pyv.declare_update\ndef upd(time_info=None):\n    pyv.systems_proc()\n    pyv.flip()\n</code></pre> <p>Here we use our systems, then use flip in order to display everything.</p> <p>And now, your game should look something like this </p> <p></p> <p>So, as of now, we can display things on our screen, but nothing more happens.</p> <p>We will change this in the 3rd step, we will start adding movement and interactions for everything.</p>"},{"location":"Game%20Tutorials/Breakout/#step-3-making-our-game","title":"Step 3 : Making our game","text":"<p>So, let's get all of this moving !</p> <p>Go back to your <code>systems.py</code> file and now we will populate the different empty systems.</p> <pre><code>def controls_sys(entities, components):\n    #Empty for now\n\ndef physics_sys(entities, components):\n    #Empty for now\n</code></pre> <p>We will start with the easiest one first, the controls.</p> <pre><code>def controls_sys(entities, components):\n    pg = pyv.pygame\n\n    player = pyv.find_by_archetype('player')[0]\n    activekeys = pg.key.get_pressed()\n    player['left'] = activekeys[pg.K_LEFT]\n    player['right'] = activekeys[pg.K_RIGHT]\n    if player['right']:\n        player['speed'] = shared.PLAYER_SPEED\n\n    if player['left']:\n        player['speed'] = -shared.PLAYER_SPEED\n\n    if not (player['left'] or player['right']):\n        player['speed'] = 0.0\n</code></pre> <p>Everything is pretty straightforward here; we search for our player, and then go inside the controls we defined earlier. Once we have our player, we just set the left and right key to the left and right controls we created. </p> <p>And after this, we make it move to the player speed on a certain direction, and if we don't press anything, he doesn't move. Even though we assigned movement to our keys, as of now, whenever we press the keys the speed is just reassigned, but it never applies to the player, so you can't move for now. </p> <p>Let's make it happen and go inside the game physics.</p> <pre><code>def physics_sys(entities, components):\n\n    ####################PLAYER MOVEMENT\n    player = pyv.find_by_archetype('player')[0]\n    pv = player['speed']\n    pp = player['body'].topleft\n    player['body'].left = pp[0]+pv\n    if(player['body'][0]&gt;900 or player['body'][0]&lt;0):\n         player['body'].left = pp[0]\n</code></pre> <p>Again, let's find our player entity.</p> <p>We take the speed property and the position as <code>pv</code> and <code>pp</code> and now we change it in the next line. <code>pp</code> is equal to the player position on X and Y, <code>pv</code> is the player \"speed\", it would be more accurate to describe it as how much the player move for a single movement.</p> <p><code>player['body'].left = pp[0]+pv</code> Here we reassign the player vertical position, this new position will be pp[0], the position in X + the \"speed\", and we have our new position.</p> <p>Lastly, we just make our player not able to leave the screen by stopping the addition of the speed.</p> <p>If everything went according to plan, you should be able to start the game and move your player block !</p> <p>Easy, right ?</p> <p>Now, we will make the ball move.</p> <pre><code>    ball = pyv.find_by_archetype('ball')[0]\n    speed_X = ball['speed_X']\n    speed_Y = ball['speed_Y']\n    bp = ball['body'].topleft\n    ball['body'].left = bp[0] + speed_X\n    ball['body'].top = bp[1]+speed_Y\n</code></pre> <p>We take the same base as before, we just now have a 2 axis movement, so we have an X and Y speed. And, same as before we apply the speed to both directions, <code>bp[0]</code> is the movement on X axis, we also add the X speed, and same for <code>bp[1]</code> and Y speed.</p> <p>Now if you test, your ball should be moving on your screen, but will go disapear once it's out.</p> <p>Let's make it stay on screen.</p> <pre><code>    if(ball['body'][0]&gt;910 or ball['body'][0]&lt;1):\n        ball['speed_X'] *= -1.05\n    if(ball['body'][1]&gt;720):\n        pyv.vars.gameover = True\n        print('lose')\n    elif(ball['body'][1]&lt;0):\n        ball['speed_Y'] *= -1.05\n\n</code></pre> <p>We're starting by making it bounce whenever it touches the right and left corner of the screen, still same as before, on [0] is the X axis, so if we cross out of screen we will send the back the ball by inversing it's direction, and making it a tiny bit faster.</p> <p>And i've decided that if it goes out under the screen, it's a lose, if it's above, it just bounces back down.</p> <pre><code>    #######################Collision\n\n    if player['body'].colliderect(ball['body']):\n        ball['body'].top = bp[1] + speed_Y\n        ball['speed_Y'] *= -1.05\n        pv *= 1.05\n\n</code></pre> <p>This is how we will handle the collision, we use <code>colliderect</code> to do so. It's a simple check inbetween the different hitboxes, whenever the hitboxes touch, <code>colliderect</code> will equal to <code>True</code>.</p> <p>So what we do is lookout to whenever they'll touch, if it do so, we change the direction and make the ball go faster. I also made the player go faster, so that it can keep up with the ball speed.</p> <p>And now for the last interaction, we will make the ball kill and bounce out of blocks :</p> <pre><code>    blocks = pyv.find_by_archetype('block')\n    for block in blocks:\n        if(ball['body'].colliderect(block['body'])):\n            pyv.delete_entity(block)\n            ball['body'].top = bp[1]+speed_Y\n            ball['speed_Y'] *= -1.05\n</code></pre> <p>We find all of our blocks, then apply basically the same treatment than the player one, except here, we use a delete_entity to remove the block once we collided with it.</p> <p>Now your game should be working ! </p> <p>And this also should be the end of the tutorial ...</p> <p>But let's add a little something to make everything cuter !</p> <pre><code>def interpolate_color(x, y) -&gt; tuple:\n    return 150, (x * 0.27) % 256, (y * 1.22) % 256\n</code></pre> <p>Add this small function in your systems.</p> <p>And let's use it to color our blocks !</p> <p>In your <code>rendering_sys</code> :</p> <pre><code>    pyv.draw_rect(scr, interpolate_color(b['body'][0], b['body'][1]), b['body'])\n</code></pre> <p></p> <p>And now your game is truly finished !</p>"},{"location":"Game%20Tutorials/Platformer/","title":"Tutorial platformer","text":"<p>This tutorial is here to help you create a platformer game, by building upon an existing foundation.</p> <p>We use the platformer template available within the <code>pyved-engine</code> package.</p> <p>More precisely we will use the built-in <code>pyv-cli</code> command.</p> <p>If you need further help for using PYV, you can always refer to the pyved-engine full docs homepage.</p>"},{"location":"Game%20Tutorials/Platformer/#step-0-getting-started","title":"Step 0. Getting started","text":""},{"location":"Game%20Tutorials/Platformer/#download-and-init-the-game-template-platformer","title":"Download and init. the game template (Platformer)","text":"<p>If you havent done it yet, to install PYV, type:</p> <pre><code>pip install pyved-engine\n</code></pre> <p>Next, you can type (still in the shell):</p> <pre><code>pyv-cli init myGame\npyv-cli play myGame\n</code></pre> <p>When prompted about the game template, select 2 to follow this tutorial.</p>"},{"location":"Game%20Tutorials/Platformer/#file-structure","title":"File structure","text":"<p>Let's go for a quick tour around the code in order for you to best understand how to customize this template to your liking.</p> <p>The files to customize are located inside of the <code>cartridge</code> folder : </p> <ul> <li> <p><code>shared.py</code> : This file will store all of your constants.</p> </li> <li> <p><code>gamedef.py</code> : This file will store your game loop thanks to 3 declaration available with pyved, declare_begin that will init your game, declare_update that will keep your update loop, and then declare_end to end the game. You will also keep your entities setup here.</p> </li> <li> <p><code>systems.py</code> : This file will keep the logic of your game through the ECS systems, if you want to implement some kind of logic events, you will have them stored here.</p> </li> <li> <p><code>World.py</code> : This file will have your entity creation in the game world.</p> </li> </ul> <p>When testing that demo, at any time you can press ESCAPE to quit the demo.</p> <p>Enough chit-chat, let's jump right into coding.</p> <p>It's time to add our first bonus- feature! What if we give a jetpack to our player?!</p>"},{"location":"Game%20Tutorials/Platformer/#step-1-all-i-want-is-a-jetpack","title":"Step 1. All I want is a Jetpack!","text":"<p>Let's make your first feature : </p> <p>We will start simple, and define what we will need for a Jetpack to work :</p> <ul> <li> <p>Add a Jetpack attribute to the player, your character will need it to use a jetpack \ud83d\ude0a</p> </li> <li> <p>A jetpack speed ratio; we could technically use the same speed as the player one, but it feels better to have a difference of speed when switching mode \ud83d\ude80</p> </li> <li> <p>And finally, the logic !</p> </li> </ul> <p>So, let's start by adding the jetpack attributes to our player.</p>"},{"location":"Game%20Tutorials/Platformer/#adding-a-jetpack-component","title":"Adding a jetpack component","text":"<p>Go into <code>World.py</code> and <code>gamedef.py</code> </p> <p><code>World.py</code>  We first have this code : </p> <pre><code>        pyv.init_entity(player, {\n            'speed': [0.0, 0.0],\n            'accel_y': 0.0,\n            'gravity': 14.5,\n            'lower_block': None,\n            'body': pygame.rect.Rect(shared.SPAWN[0], shared.SPAWN[1], shared.AVATAR_SIZE, shared.AVATAR_SIZE),\n            'camera': cam_ref,\n            'controls': {'up': False, 'down': False, 'left': False, 'right': False}\n            })\n</code></pre> <p>We will add a jetpack attribute inside of the player entity </p> <pre><code>        pyv.init_entity(player, {\n            'speed': [0.0, 0.0],\n            'accel_y': 0.0,\n            'gravity': 14.5,\n            'lower_block': None,\n            'jetpack': False,\n            'body': pygame.rect.Rect(shared.SPAWN[0], shared.SPAWN[1], shared.AVATAR_SIZE, shared.AVATAR_SIZE),\n            'camera': cam_ref,\n            'controls': {'up': False, 'down': False, 'left': False, 'right': False}\n            })\n</code></pre> <p>Now, let's dive into the <code>gamedef.py</code> file : </p> <pre><code>    pyv.define_archetype('player', (\n        'speed', 'accel_y', 'gravity', 'lower_block', 'body', 'camera', 'controls'\n    ))\n</code></pre> <p>And we also add the jetpack here :</p> <pre><code>    pyv.define_archetype('player', (\n        'speed', 'accel_y', 'gravity', 'lower_block', 'jetpack', 'body', 'camera', 'controls'\n    ))\n</code></pre>"},{"location":"Game%20Tutorials/Platformer/#tuning-the-jetpack-power","title":"Tuning the jetpack power!","text":"<p>This step is pretty straightforward, go inside the <code>shared.py</code> file</p> <p>We will simply add the attribute constant here :</p> <pre><code>JETPACK_RATIO = 0.05\n</code></pre>"},{"location":"Game%20Tutorials/Platformer/#jetpack-steering","title":"Jetpack steering?","text":"<p>This is now the hard part, lets add logic to our code in order to be able to interract with the jetpack.</p> <p>Let's go inside  <code>systems.py</code>, now find the block <code>def steering_sys(...):</code></p> <p>That chunk of code represents the system that handles the player movement. The way we will handle our jetpack is to check if our player is using it, in order to disable the jump if the player is using the jetpack since it will replace it. What we need to do is: find the following line..</p> <pre><code>ctrl['down'] = activekeys[pg.K_DOWN]\n</code></pre> <p>Right beneath that line, we will add this code:</p> <pre><code>        if not prevdown_key_value and ctrl['down']:\n            ent['jetpack'] = not ent['jetpack']\n            print('JETPACK:', ('on' if ent['jetpack'] else 'off'))\n</code></pre> <p>this will act like a switch on the jetpack flag, tied to the Player entity.</p> <p>Next, we can go inside the game and check if the console we start it from displays the jetpack on/off message whenever we press the arrow up key.</p> <p>It displays fine, but we still jump, no jetpack power is available... Let's fix this ! Still in steering system, you need to find a chunk of code that looks like this:</p> <pre><code>        if ent['lower_block']:\n            if not prevup_key_value and ctrl['up']:\n                ent['accel_y'] -= shared.JUMP_POWER\n                ent['lower_block'] = None\n</code></pre> <p>And this is how we handle our jump mechanic, we will extend this logic (add a condition over it, make it more complex) in order to create a scenario where:</p> <p>In one case: player uses the jetpack, and in the other case player simply jumps.</p> <pre><code>        if not ent['jetpack']:\n            if ent['lower_block']:\n                if not prevup_key_value and ctrl['up']:\n                    ent['accel_y'] -= shared.JUMP_POWER\n                    ent['lower_block'] = None\n        else:  # other rules apply!\n            if ctrl['up']:\n                ent['accel_y'] = -shared.JUMP_POWER * shared.JETPACK_RATIO\n</code></pre> <p>As you can see above, we basically use the same formula to calculate our jumping acceleration, we just multiply it with the <code>JETPACK_RATIO</code> we've set earlier.</p> <p>If you've modified everything as we explained, you should be able to trigger the jetpack (using the DOWN ARROW), and now you (using the UP ARROW) you will have a new exciting way to move around our little virtual world!</p>"},{"location":"Game%20Tutorials/Platformer/#step-2-adding-textures-to-our-game","title":"Step 2. adding textures to our game","text":"<p>Our game as of now, works well as a technical demo, but it is a bit sad to play only with blocks, isn't it ?</p> <p>So let's fix this !</p> <p>We will add textures to our walls, our player and a background ! </p> <p>Let's setup pydev to distribute the images across the code. You will need three files: <code>background.png</code>, <code>wall_small.png</code>, and <code>barry.png</code>. If you don't want to draw your own pixel art, we provide you with sample files in the: following folder You can download the 3 and put it in the <code>cartridge/</code> folder of your game.</p> <p>Now open the <code>metadat.json</code> file to edit it. We need list new game assets, in the <code>assets</code> field:</p> <pre><code>\"assets\": [\n    \"my_map.ncsv\", \"background.png\", \"wall_small.png\", \"barry.png\"\n],\n</code></pre> <p>These assets will get loaded automatically (pre-loading assets is a feature our game engine relies on) PYV handles the loading of images from your drive to your program. So we have added our background, our wall texture and our player image.</p> <p>However, since we are unsure whether the size of our assets matches the needs of our game, it looks safer to prepare assets manually, by rescaling images.</p> <p>You will see 2 ways for preparing/rescaling your assets:  you can chose which one you prefer for your game, however, one is suboptimized, and can be harmful to the game performance in some cases.</p>"},{"location":"Game%20Tutorials/Platformer/#prepare-assets-method-1","title":"Prepare assets: method 1","text":"<p>Let's start with modifying the player entity.</p> <p>Once again, go to <code>gamedef.py</code>, inside the function <code>troid_init(...)</code> add a component named <code>icon</code> add the player archetype:</p> <pre><code>    pyv.define_archetype('player', (\n        'speed',\n        'accel_y',\n        'gravity',\n        'lower_block',\n        'body',\n        'camera',\n        'controls',\n        'icon'\n    ))\n</code></pre> <p>Next, go to <code>World.py</code>,  search for the <code>create_avatar</code> method.  Here, at the very beginning of the method, we will create an <code>icon</code> variable, add the following lines above the <code>pyv.new_from_archetype(...)</code> call</p> <pre><code>        player_image = pyv.vars.images['barry']\n        icon = pygame.transform.scale(player_image, (shared.AVATAR_SIZE, shared.AVATAR_SIZE))\n</code></pre> <p>Then, at the player entity initialization, we can set a value for the component <code>icon</code>:</p> <pre><code>        pyv.init_entity(player, {\n            'speed': [0.0, 0.0],\n            'accel_y': 0.0,\n            'gravity': 14.5,\n            'lower_block': None,\n            'jetpack': False,\n            'body': pygame.rect.Rect(shared.SPAWN[0], shared.SPAWN[1], shared.AVATAR_SIZE, shared.AVATAR_SIZE),\n            'camera': cam_ref,\n            'controls': {'up': False, 'down': False, 'left': False, 'right': False},\n            'icon': icon\n        })\n</code></pre> <p>Here we load our image from the pyved image loader, and then resize it. This is suboptimized because it is resized everytime the player is loaded, in this case, it is not that problematic since the player is only loaded whenever the level is created.</p>"},{"location":"Game%20Tutorials/Platformer/#prepare-assets-method-2","title":"Prepare assets: method 2","text":"<p>Let's now add our background and wall texture, to do so, we will use another approach from the one before We will create a dictionnary where all of our images will be kept. So go into <code>shared.py</code> and add at the end of the file, the block:</p> <pre><code>gam_assets = dict()\n\n\ndef prepare_game_assets():\n    global gam_assets\n    gam_assets['bg'] = pygame.transform.scale(pyv.vars.images['background'], (WIDTH, HEIGHT))\n    gam_assets['wall'] = pygame.transform.scale(pyv.vars.images['wall_small'], (BLOCKSIZE, BLOCKSIZE))\n</code></pre> <p>Here you can see we created new constants for images, and transformed them to match the size we're using in the project.</p> <p>This function needs to be called at the beginning of our program, so add it in the <code>init_troid(...)</code> function, in the <code>gamedef.py</code> file.</p> <pre><code>def troid_init(vms=None):\n    pyv.init()\n    screen = pyv.get_surface()\n    shared.screen = screen\n    shared.prepare_game_assets()\n</code></pre>"},{"location":"Game%20Tutorials/Platformer/#use-assets-for-real-just-do-it","title":"Use assets. For real, just do it","text":"<p>Since all assets are now ready (loaded into the memory at runtime), the rest of the task is to adapt what's rendered by replacing the colored squares with real images. To do so, navigate to <code>systems.py</code>, in the <code>rendering_sys</code>.</p> <p>Let's first add the background, just after the background fill :</p> <pre><code>    scr.fill((0, 27, 0))\n    scr.blit(shared.gam_assets['bg'], [0, 0])\n</code></pre> <p>And look for thi chunk of code, we will replace it:</p> <pre><code>    # draw player!\n    disp(scr, pl_ent, 'red')\n    # draw blocks\n    li_blocks = pyv.find_by_archetype('block')\n    for b in li_blocks:\n        disp(scr, b, 'blue')\n</code></pre> <p>The new version is:</p> <pre><code> # draw player!\n    disp(scr, pl_ent, img=pl_ent['icon'])\n    # draw blocks\n    li_blocks = pyv.find_by_archetype('block')\n    for b in li_blocks:\n        disp(scr, b, img=shared.gam_assets['wall'])\n</code></pre> <p>Watch out, do not modify <code>mob_blocks</code> (displayed in orange) We're all done for that step!</p> <p>One could add more textures for the moving blocks for example, but we wanted to keep it as surface level as possible.</p>"},{"location":"Game%20Tutorials/Platformer/#step-3-adding-a-new-type-of-entity","title":"Step 3. Adding a new type of Entity","text":"<p>Now, let's get our hands dirty with some hard stuff!</p> <p>We will create a block that allows us to change levels. There's many other way to decline the code used, so be creative.</p> <p>We will first modify our map data and add a new block somewhere, put it wherever you want. The map data is stored in the file: <code>my_map.ncsv</code> You can see the map is encoded as a matrix of numbers: 0, 1, 2 and 3 are used codes. 0 denotes the empty space for example. 1 denotes regular walls etc.</p> <p>Let's keep going and declare a new type of block by adding a 4 value somewhere. It's better to replace a 0 value somewhere on the 15th line (it is approximatively the floor on which the player is walking) by the new value 4.</p>"},{"location":"Game%20Tutorials/Platformer/#modding-the-game","title":"Modding the game","text":"<p>Data has changed, but not the game itself.</p> <p>Once your <code>my_map.ncsv</code> is saved, go into <code>gamedef.py</code>, where we will add a new archetype As defined before, the archetypes allows us to creates new entities with special rules.</p> <p>Go after the existing list of archetypes and let's add our new block, the <code>tp_block</code></p> <pre><code>    pyv.define_archetype('tp_block', ['body', ])\n</code></pre> <p>Here we just added the property <code>body</code> to our block, because we just need it to have an actual hitbox, the logic of what happens whenever we reach the blocks is elsewhere.</p> <p>Now that our archetype exists, we need our world to know who's this new kid in the block.</p> <p>Go inside the <code>World.py</code> file and under the <code>add_terrain_blocks</code> function.</p> <p>Since this function handles the initialisation and properties of blocks, let's add the logic: how to process our value \"4\", link it to a <code>tp_block</code> entity: Be careful, this needs to be added inside the for loop, not outside.</p> <pre><code>            elif btype == 4:\n                pyv.init_entity(\n                    pyv.new_from_archetype('tp_block'), {\n                        'body': rrect\n                    }\n                )\n                self._platforms.append(rrect)\n</code></pre> <p>We give the property <code>rect</code> to the <code>body</code>,  this will allow us to give the block a proper hitbox.</p> <p>Now we will take a small break from all of this hard stuff, and create our new map, we will need it to load somewhere. Just create a <code>map2.ncsv</code> file by copying the first one and change a few blocks here and there!</p> <p>Also make sure that you list the: <code>map2.ncsv</code> file in your list of assets to load, as specified in your <code>metadat.json</code> file (just append the name <code>map2.ncsv</code> at the end af the existing asset list)</p>"},{"location":"Game%20Tutorials/Platformer/#loading-another-world","title":"Loading another world","text":"<p>We're almost done!</p> <p>Hang in there! You're doing great.</p> <p>Go to <code>systems.py</code> and draw our new block on the map, go back to the same place where we previously (Step 2. of the tutorial) changed how way blocks are displayed. It's around line 200 of that file. Add the following line after the display of orange blocks:</p> <pre><code>    temp = pyv.find_by_archetype('tp_block')\n    if len(temp):\n        tp_block = temp[0]\n        disp(scr, tp_block, 'purple', 3)\n</code></pre> <p>Now that the block is present on the map, let's add some logic for it, in order to make it truly a new feature.</p> <p>We will call a function named <code>_proc_unload_load</code>, that is already defined. You don't need to worry about writing that part, but it can be useful for you to understand how we proceed.</p> <p>In that pre-defined function, all we do is using the component <code>next_map</code> to tell the game where the player should be teleported to, and we re-create the avatar entity. Here's the code we refer to:</p> <pre><code>def _proc_unload_load():\n    player = pyv.find_by_archetype('player')[0]\n    camref = player['camera']\n    pyv.wipe_entities()\n    shared.world.load_map(player['next_map'])\n    shared.world.create_avatar(camref)\n</code></pre> <p>Now, go inside the <code>teleport_sys</code> (a system that handles player teleportation), at the end of that function please add:</p> <pre><code>    temp = pyv.find_by_archetype('tp_block')\n    if len(temp):\n        tp_block = temp[0]\n        if player['body'].colliderect(tp_block['body']):\n            player['next_map'] = 'map2'\n            _proc_unload_load()\n</code></pre> <p>Here what we're doing is creating a var <code>temp</code> that will reference our <code>tp_block</code>, and thanks to <code>colliderect</code> we will detect if the 2 blocks are colliding. Once they collide, we just move our player to the next map, by unloading the current map and loading the next one.</p> <p>Hopefully, your game now looks like this! You are now able to travel between two different worlds... Two independant maps!</p> <p></p> <p>Et voila... You're done! Amazing isn't it? Congrats for completing this tutorial.</p> <p>If something is wrong/ if the program crashes, make sure to read again all previous steps, one by one and check if you haven't forgot anything. In case this is not enough to find the solution, you can always join our Discord community and ask for help. More advanced PYV users will be glad to help you!</p> <p>Now go ahead, imagine a fourth or even a fifth feature to add by yourself! One interesting feature for example could be: a special code in the map model, to specify where the player should respawn...</p> <p>But hey, it's your role to be creative! You are a game dev now. Have fun, coding with PYV.</p>"}]}